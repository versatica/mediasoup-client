/**
 * Fill the given RTP parameters for the given mid or sending track.
 *
 * @param {RTCRtpParameters} rtpParameters -  RTP parameters to be filled.
 * @param {Object} sdpObj - Local SDP Object generated by sdp-transform.
 * @param {MediaStreamTrack} track
 * @param {String} [mid]
 * @param {Boolean} [planBSimulcast]
 */
export function fillRtpParametersForTrack(
	rtpParameters, sdpObj, track, { mid = null, planBSimulcast = false } = {}
)
{
	const mSection = findMediaSection(sdpObj, track, mid);

	if (mid !== null && mid !== undefined)
		rtpParameters.muxId = String(mid);

	rtpParameters.rtcp =
	{
		cname       : null,
		reducedSize : true,
		mux         : true
	};

	// Get the SSRC and CNAME.

	const ssrcCnameLine = (mSection.ssrcs || [])
		.find((line) => line.attribute === 'cname');

	if (!ssrcCnameLine)
		throw new Error('CNAME value not found');

	rtpParameters.rtcp.cname = ssrcCnameLine.value;

	// Standard simylcast based on a=simulcast and RID.
	if (!planBSimulcast)
	{
		// Get first (and may be the only one) ssrc.
		const ssrc = ssrcCnameLine.id;

		// Get a=rid lines.

		// Array of Objects with rid and profile keys.
		const simulcastStreams = [];

		for (const rid of mSection.rids || [])
		{
			if (rid.direction !== 'send')
				continue;

			if (/^low/.test(rid.id))
				simulcastStreams.push({ rid: rid.id, profile: 'low' });
			else if (/^medium/.test(rid.id))
				simulcastStreams.push({ rid: rid.id, profile: 'medium' });
			if (/^high/.test(rid.id))
				simulcastStreams.push({ rid: rid.id, profile: 'high' });
		}

		// Fill RTP parameters.

		rtpParameters.encodings = [];

		if (simulcastStreams.length === 0)
		{
			const encoding = { ssrc };

			rtpParameters.encodings.push(encoding);
		}
		else
		{
			for (const simulcastStream of simulcastStreams)
			{
				const encoding =
				{
					encodingId : simulcastStream.rid,
					profile    : simulcastStream.profile
				};

				rtpParameters.encodings.push(encoding);
			}
		}
	}
	// Simulcast based on PlanB.
	else
	{
		// First media SSRC (or the only one).
		let firstSsrc;

		// Get all the SSRCs.

		const ssrcs = new Set();

		for (const line of mSection.ssrcs || [])
		{
			if (line.attribute !== 'msid')
				continue;

			const ssrc = line.id;

			ssrcs.add(ssrc);

			if (!firstSsrc)
				firstSsrc = ssrc;
		}

		if (ssrcs.size === 0)
			throw new Error('no a=ssrc lines found');

		// Get media and RTX SSRCs.

		const ssrcToRtxSsrc = new Map();

		// First assume RTX is used.
		for (const line of mSection.ssrcGroups || [])
		{
			if (line.semantics !== 'FID')
				continue;

			let [ ssrc, rtxSsrc ] = line.ssrcs.split(/\s+/);

			ssrc = Number(ssrc);
			rtxSsrc = Number(rtxSsrc);

			if (ssrcs.has(ssrc))
			{
				// Remove both the SSRC and RTX SSRC from the Set so later we know that they
				// are already handled.
				ssrcs.delete(ssrc);
				ssrcs.delete(rtxSsrc);

				// Add to the map.
				ssrcToRtxSsrc.set(ssrc, rtxSsrc);
			}
		}

		// If the Set of SSRCs is not empty it means that RTX is not being used, so take
		// media SSRCs from there.
		for (const ssrc of ssrcs)
		{
			// Add to the map.
			ssrcToRtxSsrc.set(ssrc, null);
		}

		// Fill RTP parameters.

		rtpParameters.encodings = [];

		const simulcast = ssrcToRtxSsrc.size > 1;
		const simulcastProfiles = [ 'low', 'medium', 'high' ];

		for (const [ ssrc, rtxSsrc ] of ssrcToRtxSsrc)
		{
			const encoding = { ssrc };

			if (rtxSsrc)
				encoding.rtx = { ssrc: rtxSsrc };

			if (simulcast)
				encoding.profile = simulcastProfiles.shift();

			rtpParameters.encodings.push(encoding);
		}
	}
}

/**
 * Adds multi-ssrc based simulcast (PlanB) into the given SDP for the given mid
 * or track.
 * NOTE: This is for Chrome/Safari using Unified-Plan with legacy simulcast.
 *
 * @param {Object} sdpObj - Local SDP Object generated by sdp-transform.
 * @param {MediaStreamTrack} track
 * @param {String} [mid]
 */
export function addPlanBSimulcast(sdpObj, track, { mid = null } = {})
{
	const mSection = findMediaSection(sdpObj, track, mid);

	// Get the SSRC.

	const ssrcMsidLine = (mSection.ssrcs || [])
		.find((line) => line.attribute === 'msid');

	if (!ssrcMsidLine)
		throw new Error('a=ssrc line with msid information not found');

	const ssrc = ssrcMsidLine.id;
	const msid = ssrcMsidLine.value.split(' ')[0];
	let rtxSsrc;

	// Get the SSRC for RTX.

	(mSection.ssrcGroups || [])
		.some((line) =>
		{
			if (line.semantics !== 'FID')
				return;

			const ssrcs = line.ssrcs.split(/\s+/);

			if (Number(ssrcs[0]) === ssrc)
			{
				rtxSsrc = Number(ssrcs[1]);

				return true;
			}
		});

	const ssrcCnameLine = mSection.ssrcs
		.find((line) => (line.attribute === 'cname' && line.id === ssrc));

	if (!ssrcCnameLine)
		throw new Error('CNAME line not found');

	const cname = ssrcCnameLine.value;
	const ssrc2 = ssrc + 1;
	const ssrc3 = ssrc + 2;

	// mSection.ssrcGroups = mSection.ssrcGroups || [];
	mSection.ssrcGroups = [];
	mSection.ssrcs = [];

	mSection.ssrcGroups.push(
		{
			semantics : 'SIM',
			ssrcs     : `${ssrc} ${ssrc2} ${ssrc3}`
		});

	mSection.ssrcs.push(
		{
			id        : ssrc,
			attribute : 'cname',
			value     : cname
		});

	mSection.ssrcs.push(
		{
			id        : ssrc,
			attribute : 'msid',
			value     : `${msid} ${track.id}`
		});

	mSection.ssrcs.push(
		{
			id        : ssrc2,
			attribute : 'cname',
			value     : cname
		});

	mSection.ssrcs.push(
		{
			id        : ssrc2,
			attribute : 'msid',
			value     : `${msid} ${track.id}`
		});

	mSection.ssrcs.push(
		{
			id        : ssrc3,
			attribute : 'cname',
			value     : cname
		});

	mSection.ssrcs.push(
		{
			id        : ssrc3,
			attribute : 'msid',
			value     : `${msid} ${track.id}`
		});

	if (rtxSsrc)
	{
		const rtxSsrc2 = rtxSsrc + 1;
		const rtxSsrc3 = rtxSsrc + 2;

		mSection.ssrcGroups.push(
			{
				semantics : 'FID',
				ssrcs     : `${ssrc} ${rtxSsrc}`
			});

		mSection.ssrcs.push(
			{
				id        : rtxSsrc,
				attribute : 'cname',
				value     : cname
			});

		mSection.ssrcs.push(
			{
				id        : rtxSsrc,
				attribute : 'msid',
				value     : `${msid} ${track.id}`
			});

		mSection.ssrcGroups.push(
			{
				semantics : 'FID',
				ssrcs     : `${ssrc2} ${rtxSsrc2}`
			});

		mSection.ssrcs.push(
			{
				id        : rtxSsrc2,
				attribute : 'cname',
				value     : cname
			});

		mSection.ssrcs.push(
			{
				id        : rtxSsrc2,
				attribute : 'msid',
				value     : `${msid} ${track.id}`
			});

		mSection.ssrcGroups.push(
			{
				semantics : 'FID',
				ssrcs     : `${ssrc3} ${rtxSsrc3}`
			});

		mSection.ssrcs.push(
			{
				id        : rtxSsrc3,
				attribute : 'cname',
				value     : cname
			});

		mSection.ssrcs.push(
			{
				id        : rtxSsrc3,
				attribute : 'msid',
				value     : `${msid} ${track.id}`
			});
	}
}

function findMediaSection(sdpObj, track, mid)
{
	let mSection;

	if (mid !== null && mid !== undefined)
	{
		mid = String(mid);

		mSection = (sdpObj.media || [])
			.find((m) => String(m.mid) === mid);

		if (!mSection)
			throw new Error(`SDP section with mid=${mid} not found`);
	}
	else
	{
		mSection = (sdpObj.media || [])
			.find((m) => (
				m.type === track.kind &&
				m.msid &&
				m.msid.split(' ')[1] === track.id
			));

		if (!mSection)
			throw new Error(`SDP section with a=msid containing track.id=${track.id} not found`);
	}

	return mSection;
}
